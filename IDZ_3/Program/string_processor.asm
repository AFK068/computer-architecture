.globl	string_refactor strcpy

string_refactor:
	mv	a0	s3				# Пермещаем нидекс начала строки в a0
	mv	a3	a0				# Сохраняем адресс начала строки
	
	loop:
		lbu	t0	(a0)			# Считываем симовол
		beqz	t0	fin			# Если это конец строки то прыгаем в подпрограмму завершения цикла (fin)
		
		# Отсекаем все ненужные сииволы, т.е. все что не строчная буква
		#----------------------------------------------------------------------------------------------------------------
		li	a1	'a'
		li 	a2	'z' 			
		
		blt	t0	a1	continue	# Если ASCCII код меньше чем сивол 'a' то пропускаем данный символ
		bgt	t0	a2	continue	# Если ASCCII код больше чем сивол 'z' то пропускаем данный символ
		#----------------------------------------------------------------------------------------------------------------
		
		
		# Если у нас считанный символ гласная буква то перекодим к следующему
		#----------------------------------------------------------------------------------------------------------------		
		li	a1	'a'
		beq	t0	a1 	continue
		
		li	a1	'e'
		beq	t0	a1 	continue
		
		li	a1	'i'
		beq	t0	a1 	continue
		
		li	a1	'o'
		beq	t0	a1 	continue
		
		li	a1	'u'
		beq	t0	a1 	continue
		#----------------------------------------------------------------------------------------------------------------
		
		# То есть мы все "нехорошие" символы отсекли и у нас остались только согласные буквы.
		# Теперь вычитаем из ASCII текущей буквы 32, чтобы получить заглавную версию буквы.
		#----------------------------------------------------------------------------------------------------------------
		addi	t0	t0	-32
		sb	t0	(a0)
		
		j	continue
		#----------------------------------------------------------------------------------------------------------------
		
	continue:
		addi	a0	a0	1		# Переходим на следующий символ
		j	loop				# Возвращаемся обратно в цикл
		
	fin:
		mv	a0	a3			# Возвращаем в a0 индекс начала нашей "строки"
		ret
			
strcpy:
	loop_copy:
		lb	t0, (a5)
		sb	t0, (a6)
		beqz	t0, end
		addi	a5, a5, 1
		addi	a6, a6, 1
		b	loop_copy
		
	end:
		ret
