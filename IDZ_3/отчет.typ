#import "template.typ": *
#let title = "ИДЗ-3"
#let author = "Гобец Иван Евгеньевич. БПИ 237. Вариант 18"
#let course_id = "АВС"
#let semester = "Ноябрь 2024"
#set enum(numbering: "1)")
#show: assignment_class.with(title, author, course_id, semester)

#prob([
  *Разработать программу, заменяющую все согласные буквы в заданной ASCII–строке на заглавные.*
], "Условие варината 18")

#prob([
  Отчет сразу начинается с оценки на 10, так как, спросив у семинариста, он сказал, что можно так сделать. 

  - Далее буду предоставлять блоки по различным частям кода (для понятности, чтобы не было все подряд). 
  - Ещё я пытался, все строчки кода комментировать для более понятного пояснения в отчете. 
], "Отчет на 10")

#prob([
  - Начну с малой "функции" это копирование строки с адресса *a5* в *a6*. Цикл *loop_copy* в котором происходит само копирование строки. В *t0* загружаем значение с *a5* и записываем его в *a6*, после проверям текущий символ это конец строки или нет (т.е. 0), если это так, то заканчиваем копирование, иначе к добаляем в *a5* и *a6*, т.е. переходим к следующему символу и запускаем цикл заново.
  #image("png/2.png") \

  - Для начала снова повторим условие варианта:  *Разработать программу, заменяющую все согласные буквы в заданной ASCII–строке на заглавные.* Далее я разберу свой код и поясню логику его работы.
  - Мне нужно все согласнеы буквы заменить на заглавные. Для начала я загружу в a1, a2 ASCII значения строчной буквы a и z. И сразу проверю, если текущий символ не лежит в диапозоне $[a_1, a_2]$, значит это не строчная буква, соедовательно я сразу такой символ пропускаю. 
  - Далее я проверяю, что текущий символ это не согласная строчая буква. Всего будет 5 "if" на каждую гласную букву, если текущий символ гласная буква, то я пропускаю его.
  - После всех проверок я могу удостовериться, что текущий символ это строчная согласная буква. Теперь мне достаточно от текущего символа отнять *32* и это будет соответствующая согласная буква, но уже заглавная. Потом меняем текущую букву в строке и все готово.
  #image("png/1.png")
], "Файл производящий работу со строкаму (string_processor.asm)") 
#pagebreak()

#prob([
  - *print_int (%x)* - макрос для печати содержимого заданного ригистра как целого.
  - *print_imm_int (%x)* - макрос для печати непосредственного целочисленного значения.
  - *print_str (%x)* - макрос для печати строковой константы, ограниченной нулевым символом.

  #image("png/3_1.png")


  - *print_char(%x)* - макрос для вывода отдельного заданного символа.
  - *new_line* - макрос для перевода строки.
  - *read_int_a0* - макрос для ввода целого числа и запись его в регист *a0*
  - *read_int(%x)* - макрос для ввода целого числа с консоли в указанный регистр, исключая регистр a0.
  #image("png/3_2.png")

  - *str_get(%strbuf, %size)* - макрос для ввода строки в буфер заданного размера с заменой перевода строки нулем. *%strbuf* - адрес буфера, *%size* - целая константа, ограничивающая размер вводимой строки.
  - *open* - макрос для открытия файла для чтения, записи, дополнения
    - .eqv READ_ONLY	0	- Открыть для чтения
    - .eqv WRITE_ONLY	1	- Открыть для записи
    - .eqv APPEND	    9	- Открыть для добавлени
  - *read* - макрос для чтения информации из открытого файла.
  #image("png/3_3.png") 

  - *read_addr_reg(%file_descriptor, %reg, %size)* - макрос для чтения информации из открытого файла, когда адрес буфера в регистре
  - *close(%file_descriptor)* - макрос для закрытия файла.
  - *allocate(%size)* - макрос для выделения области динамической памяти заданного размера.
  - *exit* - макрос для завершения работы программы.
  - *push(%x) * - макрос для сохранения заданного регистра на стеке.
  - *pop(%x)* - макрос для выталкивания значения из стека в заданный регистр. 
  #image("png/3_4.png") 

  - *accept_if(%save, %first, %second)* - макрос для записывания в %save 1, если %first и %second равны, иначе 0.
  - *print_string(%x)* - макрос для вывода строки в консольб
  - *strcpy* - макрос для копирования строки, содержащий подпрограмму *strcpy*.
  - *print_new_line_if(%x)* - макрос для выводы новой строки, если в *%s* лежит 1.
  #image("png/3_5.png")
], "Библиотека макросов (macro-syscalls.m)")
#pagebreak()


#prob([
  Данная подпрограмма *get_settings* собирает информации у пользователя: 1) Хочет ли он, чтобы подпрограмма протестировалась автоматически; 2) Хочет ли он, чтобы результат вывелся в консоль. 
  
  Разберем работу данной подпрограммы:\
  - *get_settings_autotest* - Выводим пользователю строку - "Autotest the program (Y/N): " и считываем его ответ. Далее записываем в *a1* ввод пользовател и в *2* ASCII код символа 'Y'. Далее вызываем макрос *accept_if*, в котором произойдет сравнивание двух строк и если они равна, то в *s7* будет лежать 1, иначе 0.
  - *get_settings_output* - Все идентично предыдущей подпрограммы, но тут уже вывожид "Output results to console (Y/N): ", и записываем в *s8* 1, если пользователь ввел 'Y', иначе 0.
  #image("png/4.png")
], "Файл с настройками (settings.asm)") 
#pagebreak()

#prob([
  Подпрограмма *output* для вывода пользователю результата. Помним, что в *s8* хранится 1, если результат нужно вывести, иначе 0. В начале подрограммы проверяем это условие, если 0, то прыгаем в попрограмму *no_output_console* и просто вывозращаемся по адрессу. Если же 1, то выводим строку "Output: " и после выводим результат и вывозращаемся по адрессу.
  #image("png/5.png")
], "Файл работы с выводом (iomod.asm)")
#pagebreak()

#prob([
  - *read_file* - подпрограмма для чтения файла. Поснение описано подробно в коммментариях. Где *file_name* - имя файлу и *TEXT_SIZE* количество считываемых символов. 
  #image("png/6_1.png")

  #image("png/6_2.png")
  - *save_in_file* - подпрограмма для сохранения данных в файл.
  - *er_name* - в случае ошибки в имени файла, выводим строку "An error occurred - the file name is incorrect\n" и завершаем работу программы.
  - *er_read* - в случае ошибки в чтении файла, выводим строку "An error occurred during the read operation\n" и завершаем работу программы.
], "Работа с файлами (file_utils.asm)")

#prob([
  В *main* происходит логика вся работы программы. Для начала мы прыгаем в подрограмму *get_settings* (описание данной подпрограмы было написано выше), далее прыгаем в подпрограмму *state_machine*. Для начала записываем в стек адресс *ra* после, если  в *s7* лежит 1, то прыгаем в подпрограмму *autotest* (разбора этой попрограммы, будет разобран далее), иначе продолжаем работу подпрограмму. Подпрограмма *read_data* выводим "Enter the path to the file: " и запрашиваем у пользователя имя файла через макрос *str_get* далее прыгаем в подпрограмму *read_file* и счтываем содержимое файла. Далее выполнятся подпрограмма *string_refactor* и выполням бизнесс логику. После прыграем в подпрограмму *output*, где выводится результат (описание данной подпрограмы было написано выше), если *s8* равно 1, иначе не выводим. После в подпрограмме *save_data* звпрашиваем у пользователя имя файла для записи и сохраненям результат через макрос *save_in_file*. После со стека снимаем адресс *ra* с помощью макроса *pop* и возвращаемся в main, где завершаем работу программы через макрос *exit*.

  #image("png/7.png") \ \
], "Main")


#prob([
  Для начала предоставлю ручное тестирование.

  - Протестируем строку *Ajsdjhfuiy823yjahfxznmvcnejwr90	iasfmnadfn asd* лежащую по адрессу *test1.txt* с парметром вывода - *да*. И именем файла для сохранения результата *output*.
  #image("png/8_2.png")
  - Получили строку в файле *output* - *AJSDJHFuiY823YJaHFXZNMVCNeJWR90	iaSFMNaDFN aSD*
  - Работа программы прошла успешно. \ \

  - Протестируем строку *aa_ii_uu_oo_aa_oo_pp_bb* лежащую по адрессу *test6.txt* с парметром вывода - *нет*. И именем файла для сохранения результата *output123*.
  #image("png/8_1.png")
  - Получили строку в файле *output123* - *aa_ii_uu_oo_aa_oo_PP_BB*
  - Работа программы прошла успешно. \ \

  *Дале будет описана логика выполнения автотестирования*
  Объявим имена для файлов, которые будут браться в качестве читаемых и имена выходных файлов. И динамическую память для записи хранения там строк (будет удобно для тестирования).
  #image("png/9_1.png")

  Опишем логику выполнения тестирования. Для начала мы запоминаем адресс *ra* в стек. Далее копируем в *file_name* значение *test_file_name_input* (далее будет описано как мы с ним работаем) и считваем файл, рефакторим строку, выводим если пользователь поставил такой параметр и сохраняем результат в файл (имя выходного файла мы скопировали с test_file_name_output). После снимаем адресс *ra* со стека и возвращаемся в *autotest*.
  #image("png/9_3.png")

  Все тесты, их 6 штук. В каждой подпрограмме *test_i* мы копируем значение в *test_file_name_imput* из *test_case_i_input* и анологично для *test_file_name_output* из *test_case_i_output*. После прыгаем в саму логику тестирования. После всех тестов завершаем программу.
  #image("png/9_4.png")

  - Рузультат вывода автотестирования с параметром вывода - *да*.
  #image("png/9.png")

  - Рузультат вывода автотестирования с параметром вывода - *нет*.
  #image("png/9_6.png")

  - Работа всех тестов прошла успешно.
], "Тестирование")

#prob([
  Работа соответствует всем требованиям на каждую оценкую. Тестирование реализовано очень удобно и понятно. Программа работает корректно и без ошибок.
], "Вывод")