.include "macrolib.asm"
.globl	check_minus

.data
	result:			.asciz "Value e^x: "
	epsilon:		.double 0.001	# Значение еpsilon для точности
.text
check_minus:
	li		t4,	0			# Загружаем в t4 0, т.е. flag = false - не отрицательное число
	bgez		t0,	declaration_variables	# Если число больше или равно 0 то сразу переходим к расчетам
	
	li		t4,	1			# Загружаем в t4 1, т.e. flag = true - число отрицательно
	neg		t0, 	t0			# Делаем число положительным
	fcvt.d.w	ft0,	t0			# Загружаес в ft0 положительное число
	
	# ft0 - значение икса
	j		declaration_variables		# Делаем джамп в подпрограмму с расчетами
	
declaration_variables: 	
	li		a1, 	1			# Устанавливаем a1 в 1 (для использования в расчетах)
	li		t1,	1			# Устанавливаем t1 в 1 (для знаменателя)
	
	fcvt.d.w	ft1,	a1			# Начальная сумма
	fmv.d		ft2,	ft0 			# Значение x
	fmv.d		ft3,	ft1			# Начальный член ряда
	fmv.d		ft6,	ft1
	
	la		t3, 	epsilon			# Загружаем адрес переменной epsilon
	fld		ft7,	(t3)			# Загружаем значение epsilon (0.001) в регистр ft7
	fcvt.d.w	ft8,	t1			# Преобразуем t1 в double и сохраняем в ft8
	
	j		calculate_e_loop

# Регистр t1 используется как факториал для знаменателя (в цикле увеличивается на 1 на каждом шаге)
# Регистр ft2 хранит значение x (параметр ряда e^x)
# Регистр ft3 хранит текущий член ряда (начиная с первого члена)
# Регистр ft6 хранит накопленную сумму ряда (сумма всех предыдущих членов)
# Регистр ft4 хранит произведение текущего члена ряда на x (для вычисления следующего члена)
# Регистр ft5 хранит факториал, который будет делиться на текущий член ряда
# Регистр ft9 используется для вычисления значения (epsilon * предыдущий член)
# Регистр ft8 хранит предыдущий член ряда для проверки на точность (epsilon)
calculate_e_loop:		
	fmul.d		ft4, 	ft3,	ft2		# Умножаем текущий член на x (ft3 = ft3 * ft2)
			
	fcvt.d.w	ft5,	t1			# Преобразуем t1 в double для знаменателя
	fdiv.d		ft3,	ft4,	ft5		# Делим текущий член на t1 (ft3 = ft4 / ft5)
	
	fadd.d		ft6,	ft6,	ft3		# Добавляем текущий член к сумме (ft6 = ft6 + ft3)
	
	addi		t1,	t1,	1		# Увеличиваем t1 на 1 (для следующего шага)
	
	fmul.d		ft9,	ft8,	ft7		# Умножаем предыдущий шаг на epsilon
	fmv.d		ft8,	ft3			# Сохраняем текущий член в ft8
	
	flt.d		t2,	ft9,	ft3		# Сравниваем значение epsilon с текущим членом
	bnez		t2,	calculate_e_loop	# Если текущий член не меньше epsilon, продолжаем цикл
	
	# ft6 - результат
	j		print_result
	
print_result:
	beqz		t4, 	print_positive_result	# Если t4 == 0 (число было не отрицательным), делаем джамп в вывод положительного рузультата

	# ft6 - рузультат (нужно еще единцу поделить на это значение, т.к. мы не учитывали минус)
	j		print_negative_result
	
print_positive_result:
	print_string(result)				# Выводим строку для рузультата
	print_double(ft6)				# Выводим результат
	
	jalr		ra				# Возвращаемся по адрессу

print_negative_result:
	li		t1,	1			# Устанавливаем t1 в 1
	fcvt.d.w	ft10,	t1			# Преобразуем t1 в double и сохраняем в ft10
	fdiv.d		ft6,	ft10,	ft6		# Делим 1 на результат (ft6 = 1 / ft6)
	
	print_string(result)				# Выводим строку для рузультата
	print_double(ft6)				# Выводим результат
	
	jalr		ra				# Возвращаемся по адрессу
