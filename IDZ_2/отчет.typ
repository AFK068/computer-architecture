#import "template.typ": *
#let title = "ИДЗ-2"
#let author = "Гобец Иван Евгеньевич. БПИ 237. Вариант 13"
#let course_id = "АВС"
#let semester = "Ноябрь 2024"
#set enum(numbering: "1)")
#show: assignment_class.with(title, author, course_id, semester)

#prob([
  Разработать программу, вычисляющую с помощью степенного ряда с точностью не хуже $0,1%$ значение функции $e^x$ для заданного параметра $x$.
], "Условие. Вариант 13")

#prob([
Отчет сразу начинает с оценки на 6-7, а не на 4-5, так как, спросив у семинариста, он сказал, что можно так сделать. 

- Далее буду предоставлять блоки по различным частям кода (для понятности, чтобы не было все подряд). 
- Ещё я описывал, все строчки кода комментариями для более понятного пояснения в отчете. 
], "Отчет на оценку 6-7")

#prob([
  #image("assets/1.png")

], "Блок .data")

#prob([
  - *read_int(%x)* - Читает целое число из ввода и сохраняет его в указанный регистр. Параметры: %x - регистр для хранения результата.

  - *print_double(%x)* - Выводит число типа double, хранящееся в указанном регистре. Параметры: %x - регистр, содержащий число для вывода.

  - *print_string(%x)* - Выводит строку по метке. Параметры: %x - метка, содержащая адрес строки.

  - *end_program* - Завершает выполнение программы. Параметры: Нет.

  Постарался больше пояснений оставить в комментариях, чтобы было нагляднее и легече читать код.
  #image("assets/2.png", width: 100%)
], "Блок с макросами")

#prob([
  - Выводится приветствие("Welcome. This work is done by Gobets Ivan group BPI-237. Option - 13") и перенос строки(new_line) через макрос *print_string*
  - Выводим "Enter value of x: "
  - Запрашиваем int с помощью макроса read_int и сохоаняем в регистре t0
  - Конвертируем в double в регист ft0 получнное значение от пользователя
  - Вызываем функцию *calculate_e* и передаем в нее значение 
  - Далее прыгаем в подпрограмму check_minus, где t0 - значение от пользователя в формате int, ft0 - тоже значение, но в формате double
   #image("assets/3.png")
], "Блок main")

#prob([
  Блок в котором мы опредлеям какой знак введого пользователем число.
  - В t4 храним 0, если число положительное, и 1, если отрицательное
  - Если введедное число положительное то сразу переходим в блок с вычеслениями, если отрицательное, то:
    - В t4 теперь храним 0, а не 1
    - Далее меняем знак у числа на положительный
    - Теперь загружаем в ft0 значение числа
  - Прыгаем в блок с вычеслениями
  #image("assets/4.png")
], "Блок check_minus")

#prob([
  - Регистр t1 используется как факториал для знаменателя (в цикле увеличивается на 1 на каждом шаге)
  - Регистр ft2 хранит значение x (параметр ряда e^x)
  - Регистр ft3 хранит текущий член ряда (начиная с первого члена)
  - Регистр ft6 хранит накопленную сумму ряда (сумма всех предыдущих членов)
  - Регистр ft4 хранит произведение текущего члена ряда на x (для вычисления следующего члена)
  - Регистр ft5 хранит факториал, который будет делиться на текущий член ряда
  - Регистр ft9 используется для вычисления значения (epsilon $times$ предыдущий член)
  - Регистр ft8 хранит предыдущий член ряда для проверки на точность (epsilon)
  #image("assets/5.png")
], "Объявление переменнных")

#prob([
  Значем, что $e^x = limits(sum)_(n = 0)^oo (x^n)/(n!)$. \
  *Важное замечание:* на кождом шаге вместо того, чтобы вычислять факториал (мы там еще будем получать переполниение, такой способ неэффективен), мы будем просто умножать предыдущий член на x и делить n и прибавлять к сумме, такой способ более оптимальный. В какой момент нужно остановиться ? На каждой итерации мы храним предыдущий член и текущий. Мы будем умножать предыдщий член на епсилон 0.001 и смотреть, если он меньше следующего, то завершаем наш цикл. \
  Выше я объяснил локигу/метод расчетов, для пояснения кода я подробно оставил комментрии к каждой строчке.
  #image("assets/6.png")
], "Блок вычислений e^x")


#prob([
  В t4 у нас хранится знак исходного числа от пользователя. 
  - Если число было положительным, то прыгаем в подпрограмму завершения программы.
  - Если число отрицательное, то прыгаем в подпрограмму print_negative_result
  \
  - В подпрограмме print_negative_result мы в t1 кладем единичку, потом делим ее на результат вычислений и прыгаем в подпрограмму завершения программы. Делим мы единицу на наш результат, потому что мы считали для положительно икса, теперь нам нужно поделить единицу на результат, чтобы получить результат для отрицательного икса.
  \
  - Блок завершения программы, где выводим результат и завершаем программу.
  #image("assets/7.png")
], "Вывод результата и завершение программы")
\ 
#prob([
  - Тест при x = 0
  #image("assets/8_1.png")

  - Тест при x = 10
  #image("assets/8_2.png")

  - Тест при x = -10
  #image("assets/8_3.png")

  - Тест при x = 100
  #image("assets/8_4.png")

  - Тест при x = -100
  #image("assets/8_5.png")

  - Тест при x = 1000
  #image("assets/8_6.png")

  - Тест при x = -1000
  #image("assets/8_7.png")
], "Тестовое покрытие")

\ \ \ \ \ \ 
#prob([
  - В блок .data добавим строки для более красивого вывода для пользователя (еще было изменено "Test result" на "Test value").
  #image("assets/9.png")

  - Также был добвален макрос для вывода int
  #image("assets/12_4.png")

  - Изменили блок  main, теперь мы запрашиваем у пользователя ввод для автотестов, если пользователь ввел 0, то начнутся автотесты, а если нет, то программа будет работать как обычно (ручной ввод).

  - Также мы теперь используем jal, чтобы запомнить адрес откуда мы прыгаем, чтобы вернуться и закончить прграмму без подпрограммы.
  #image("assets/10.png")

  - Поменяли локику вывода рузультата, теперь если в t4 лежит 0, т.е. число положительное, то мы пгрыгаем в подпрограмму для вывода положительного, а если отрицательное, то в подпрограмму для вывода отрицательного (логика расчетов не изменилась).
  

  Потом возвращаемся в main по адресу.
  #image("assets/11.png")

  *Блок тестов. Тестируемые значения: 0, 10, -10, 100, -100, 1000, -1000* \
  - В кажом блоке мы сначало в t1 загружаем значние нашего теста. Потом выводим строку "Test result: "  и потом печатаем значение теста, и переходим на новую строку. 
  - Далее конвертируем значние теста в double и прыгаем в подпрограмму check_minus (далее там происходят все расчеты) с запоменанием адреса (jal). После вычислений мы вернемся в тест и пойдем дальше по ним.
  - Далее повторяем так происходит на всех тестах. 
  - Еще одно нововведение это вывод переноса два раза (new_double_line) для более красивого вывода.
  - После всех тестов программа завершается с помощью макроса end_program. 
  #image("assets/12_1.png")
  #image("assets/12_2.png")

  - Пример автоматического тестирования:
  #image("assets/12_3.png")
  
  - Для дополнительной проверки корректности вычислений осуществим аналогичные тестовые прогоны с использованием существующих библиотек на Python.

   #image("assets/14.png", width: 97%)

   - Результаты тестового прогона на Python совпадают с результатами, полученными в ходе работы программы на ассемблере.

  #image("assets/14_2.png")

], "Отчет на 8")


#prob([
  $ "Макросы" $
  *Оставил много комментариев для более подробного отчета.*

  - *read_int(%x)* - Читает целое число из ввода и сохраняет его в указанный регистр. Параметры: %x - регистр для хранения результата.

  - *print_int(%x)* - Выводит целое число, хранящееся в указанном регистре. Параметры: %x - регистр, содержащий число для вывода.

  - *print_double(%x)* - Выводит число типа double, хранящееся в указанном регистре. Параметры: %x - регистр, содержащий число для вывода.

  - *print_string(%x)* - Выводит строку по метке. Параметры: %x - метка, содержащая адрес строки.

  - *end_program* - Завершает выполнение программы. Параметры: Нет.

  #image("assets/13.png")
], "Отчет на 9")

#prob([
  Разбиение программ по файлам:
 - *main.asm* - главный файл программы, который содержит точку входа и вызов всех подпрограмм.
 - *iomod* - файл, который содержит подпрограммы по вводу данных.
 - *tests.asm* - файл, который содержит подпрограммы для автоматического тестирования программы.
 - *calculate_e* - файл, который содержит подпрограммы для расчета e^x. 
 Макросы выдедены в отдельную автономную библиотеку в файле *macrolib.asm*.
], "Отчет на 10")