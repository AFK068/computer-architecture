#import "template.typ": *
#let title = "ИДЗ-1"
#let author = "Гобец Иван. БПИ 237. Вариант 21"
#let course_id = "АВС"
#let semester = "Октябрь 2024"
#set enum(numbering: "1)")
#show: assignment_class.with(title, author, course_id, semester)

#prob([
Отчет сразу начинает с оценки на 6-7, а не на 4-5, так как, спросив у семинариста, он сказал, что можно так сделать. 

- Далее буду предоставлять блоки по различным частям кода (для понятности, чтобы не было все подряд). 
- Ещё я описывал, все строчки кода комментариями для более понятного пояснения в отчете. 
], "Отчет на оценку 6-7")

#prob([
  #image("png/1.png")

], "Блок .data")



#prob([
  - *read_int(%x)* - Читает целое число из ввода и сохраняет его в указанный регистр. Параметры: %x - регистр для хранения результата.

  - *print_int(%x)* - Выводит целое число, хранящееся в указанном регистре. Параметры: %x - регистр, содержащий число для вывода.

  - *print_string_adress(%x)* - Выводит строку по указанному адресу. Параметры: %x - регистр, содержащий адрес строки.

  - *print_string(%x)* - Выводит строку по метке. Параметры: %x - метка, содержащая адрес строки.

  - *end_program* - Завершает выполнение программы. Параметры: Нет.

  - *print_array(%array_ptr, %count)* - Выводит массив целых чисел. Параметры: %array_ptr - указатель на массив, %count - количество элементов в массиве.

  Постарался больше пояснений оставить в комментариях, чтобы было нагляднее и легече читать код.
  #image("png/9.png", width: 100%)
], "Блок с макрасами")

#prob([
  - Выводится приветствие("Welcome. This work is done by Gobets Ivan group BPI-237. Option - 21") и перенос строки(new_line) через макрос *print_string*
  - Загружаются адреса переменной n и массива A в регистры *t0* и *t1* соответственно. 
  - Далее прлучаем и сохраняем в *t3* ввод пользователя (int от 1 до 10, в след блоке будет подробнее пояснено, как это работает). 
  - "Копируем" *t3* в *t4*, чтобы во время заполнениния массива A не изменить значение *t3*.
  - Далее заполняем "массив" A элементами введеными пользователем.
  - "Копируем" *t3* в *t4*, чтобы во время заполнениния массива B не изменить значение *t3*.
  - Формируем отсортированный по возрастанию массив B из элементов массива A и выводим массив B внутри массив B.
  - Завершаем программу через макрос end_program.
   #image("png/3.png")
], "Блок main")
\ \ \ \

#prob([
  - Выводим в консоль (*print_get_n*)"Please enter the number of array elements from 1 to 10: ".
  - Считываем ввод пользователя через макрос *read_int* и делаем *jump* в подпрограмму *check_n_for_correctness*.
  - Смотрим, если значение введеное пользователем (a0) оказалось меньше 1 или больше 10, то делаем *jump* в подпрограмму *incorrect_n_value_back_to_get_n*, а если ввод корректен, то записываем введеное значение из *a0* в *t3* и загружаем n в память по адресу *t0*, и делаем *return* в main.
  - Подпрограмма *incorrect_n_value_back_to_get_n* : сначала выводим в конмоль "Invalid input, try again" и новую строчку и прыгаем в *get_and_save_n* (т.е. ,вообщем, мы будем запрашивать и пользователя n до тех пор, пока он не введет корректное значение).
  
  #image("png/4.png")
], "Блок получения числа от пользователя")

#prob([
  - Вывод сообщения пользователю - в начале выводится сообщение с просьбой ввести число для заполнения массива ("Enter an integer: ")
  - Считываем ввод пользователя через макрос *read_int* по адрессу *a0*.
  - Запись числа в массив - число, введенное пользователем, записывается по адресу, хранящемуся в регистре t1.
  - Обновление адреса и счетчика - адрес в регистре t1 увеличивается на размер слова (4 байта), чтобы указать на следующий элемент массива.
  - Счетчик оставшихся элементов (t4) уменьшается на 1.
  - Проверка завершения заполнения - если счетчик оставшихся элементов (t4) не равен нулю, функция повторно вызывается для заполнения следующего элемента массива:
  #image("png/5.png")
], "Блок заполнения массива A")
\ \ \ \

#prob([
  #image("png/6.png")

  - Инициализация переменных - инициализируем минимальное значение как максимальное целое число (MAX_INT) в *a3* и загружаем адрес для хранения индекса минимума в *a5* и текущий индекс в *a4*.
  - Поиск минимального - выгражаем элемент с массива A в *t6* и сравнимаем его с минимальным, если он оказался меньше минимального, то просто записываем его в *a3* и записываем текущий индекс по адрессу. И переходим к слудующему элементу (если бы у нас при сравнении, оказалось, что элемент, который мы выгрузили оказался больше минимального, то сразу переходим к следующему элементу *next_elemt*).
  - *next_element* - обновляем адресс и счетчик, адресс в *t1* увеличиваем на 4 байта и увеличиваем индекс на 1 в *a4*. Если индекс элемента меньше, чем длина массива - n (*t3*), то повторно запускаем поиск минимального элемента сделать *jump* в *find_min_element*.

  $ "Write_min_to_B" $
  После того, как все элементы будут проверены и найден минимальный элемент в массиве A, то:
  - Запись минимального элемента в массив B - записываем найденный минимальный элемент в массив B по адрессу *t2* и увеличиваем адресс *t2* на 4 байта.
  - Восстановление адреса - восстанавливаем адресс массива A в *t1*.  Далее в *a2* считываем индекс минимального элемента в массиве A. Выполняет сдвиг влево значения в регистре a2 на 2 бита, чтобы получить смещение в байтах, так как каждый элемент массива занимает 4 байта (размер слова). Добавляем к адрессу массива A смещение, чтобы получить адресс элемента по индексу, где лежит текущий минимум. После загржаем MAX_INT в *a0* и записываем его в найденный минимум в массиве A.
  - Восстановлением адреса массива A в *t1* и уменьшаем счетчик оставшихся элементов в *t4* на 1. И если не все не все элементы массива A пройдены (если у нас n в *t4* не равно 0), то повторно запускаем поиск минимального элемента (прыгаем в *sort_A_array_and_save_in_B*), а как все элементы а массиве B будет полностью заполнен, восстанавливаем адресс массива B в *t2*, выводим через макрос *print_string* (*print_sorted_B_array*: "Sorted B array: "), через макрос *print_array* выводим массив B и делаем *return* в main.

  Еще раз объясню как происходит сортировка массива. Мы ищем минимальный элемент в массиве A и записываем его в массив B. После этого в массиве A на место минимального элемента записываем максимальное целое число (MAX_INT). И так повторяем, пока не заполним массив B.
  
], " Формирование отсортированный массива B из элементов массива A")

#prob([
- Ввод числа n от пользователя и проверка его корректности. Если, число не в диапозоне от 1 до 10 включительно, программа запрашивает n снова.
#image("png/7_1.png", width: 85%)

- Массив с одним элементом. Автоматически отсортирован.
#image("png/7_2.png", width: 85%)

- Массив с одинаковыми элементами. Отсортирован корректно.
#image("png/7_3.png", width: 85%)

- Массив с одинаковыми и разными элементами. Отсортирован корректно.
#image("png/7_4.png", width: 71%)

- Массив с уже отсортированными элементами. Отсортирован корректно.
#image("png/7_5.png", width: 85%)

- Массив с элементами в обратном порядке. Отсортирован корректно.
#image("png/7_6.png", width: 85%)

- Массив с отрицательными элементами. Отсортирован корректно.
#image("png/7_7.png", width: 85%)

- Массив с положительными и отрицательными элементами. Отсортирован корректно.
#image("png/7_8.png", width: 75%)
], "Тестовое пыкрытие")


#prob([
  $ "Реализация тестов." $
  Определяем 7 "массивов" данных для автоматического тестирования программы и строку tested_A_array для вывода ("Tested array: ")
  #table(
    columns: (auto, auto, auto, auto),
    align: center,
    inset: 10pt,
    "SingleElementArray", "IdenticalElementsArray", "MixedElementsArray", "AlreadySortedArray", 
    "Массив с одним элементом", "Массив с одинаковыми элементами", "Массив с одинаковыми и разными элементами", "Уже отсортированный массив")

  #table(
    columns: (auto, auto, auto),
    align: center,
    inset: 10pt,
    "ReverseOrderArray", "NegativeElementsArray", "MixedPositiveNegativeArray", 
    "Массив с элементами расположенными в обратном порядке", "Массив с отрицательными элементами", "Массив с положительными и отрицательными элементами")


  - Когда происходит автоматическое тестирование - если пользователь укажет длину масса равную 0, то начнется автотестирование.

  - Было изменен текст для для пользователя. Теперт прописано, чтобы начать автотестирование нужно ввести 0.
  #image("png/8_3.png")

  - Теперь, если пользователь ввел 0 (тут мы проверям через beq, zero, a0 ...), то мы делаем *jump* в подпрограмму *tests*.
  #image("png/8_2.png")

  - Есть 7 блоков тестирования (не везде написанны, так как код идентичен, только меняется длинна массива и его элементы).
  - Сначала мы в *t1* записывем адресс на начала тестовых данных.
  - В *t4* храним длину массива
  - Далее нам нужно скопировать элемента тестового массива в массив A 
  - После восстанавливаем все значения, так как во время копирвоания массива они изменяются.
  - После делаем *jal* в подпрограмму *run_test_case*
  
  #image("png/8_4.png")
  #image("png/8_5.png")

  Копирование тестового массива в A
  - В *t2* храним адресс массива A
  - Далле попадаем в *copy_loop*, где смотрм если длина массива равна нулю, то переходим в подпрограмму *end_copy* где возвращаемся по адрессу.
  - Выгружаем элемент и записываем его в массив A. Потом сдвигаем адресса массивов A и тестового на 4 байта и вычитаем из счетчика 1 в *t4* потом повторяем снова, пока не скопируем полностью.
  - Главная подпрограмма тестирвоания  *run_test_case* - сначала выводим две новых строки с помощью макроса *print_string*  для красивого разделения блоков теста во время вывода.
  - Загружаем в *t2* адресс на массив B.
  - Далее выводим строку "Tested array: " с помощью макроса *print_string* и выводим тестовый массив с помощью макроса *print_array*.
  - Далее делаем *jump* в подпрограмму сортировки. *t1* адресс массива A, *t2* адрес масса B, *t3, t4* - длинна массива.
  #image("png/8_6.png")

  - Пример автоматического тестирования:
    #image("png/8_7.png")
], "Отчет на 8")

#prob([
  $ "Макросы" $
    - *read_int(%x)* - Читает целое число из ввода и сохраняет его в указанный регистр. Параметры: %x - регистр для хранения результата.

  - *print_int(%x)* - Выводит целое число, хранящееся в указанном регистре. Параметры: %x - регистр, содержащий число для вывода.

  - *print_string_adress(%x)* - Выводит строку по указанному адресу. Параметры: %x - регистр, содержащий адрес строки.

  - *print_string(%x)* - Выводит строку по метке. Параметры: %x - метка, содержащая адрес строки.

  - *end_program* - Завершает выполнение программы. Параметры: Нет.

  - *print_array(%array_ptr, %count)* - Выводит массив целых чисел. Параметры: %array_ptr - указатель на массив, %count - количество элементов в массиве.

  Постарался больше пояснений оставить в комментариях, чтобы было нагляднее и легече читать код.
  #image("png/9.png", width: 100%)
], "Отчет на 9")


#prob([
  Разбиение программ по файлам:
  - *main.asm* - главный файл программы, который содержит точку входа и вызов всех подпрограмм.
  - *iomod* - файл, который содержит подпрограммы по вводу данных.
  - *tests.asm* - файл, который содержит подпрограммы для автоматического тестирования программы.
  - *generate_B* - файл, который содержит подпрограммы для формирования массива B из массива A.

  Макросы выдедены в отдельную автономную библиотеку в файле *macrolib.asm*.
], "Отчет на 10")